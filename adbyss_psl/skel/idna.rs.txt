/// # Remappings.
///
/// This array holds all of the different IDNA/Unicode remapping sequences.
/// There is a lot of overlap, so individual remappings are referenced as
/// ranges of this array.
{map_str}

{map}

/// # Ranges.
///
/// There are several hundred IDNA/Unicode entries represented as ranges. The
/// lower and (inclusive) upper bounds, as well as the matching kind, are
/// stored in this array.
{ranges}



#[derive(Clone, Copy)]
/// # Map Index.
///
/// All of the possible mappings are stored in a contiguous char array called
/// `MAP_STR`, built at runtime. This struct is used to define a particular
/// subslice of that array, where `a` and `b` are an index, and `l` is the
/// length.
///
/// The convoluted storage method helps with the alignment of [`CharKind`].
pub(super) struct MapIdx {{
	a: u8,
	b: u8,
	l: u8,
}}



#[repr(u8)]
#[derive(Clone, Copy)]
/// # Char Kinds.
///
/// This is the IDNA/Unicode status for a given character:
/// * [`CharKind::Valid`]: The character is fine as-is.
/// * [`CharKind::Ignored`]: The character should be silently skipped.
/// * [`CharKind::Mapped`]: The character should be transformed into one or more alternative characters.
pub(super) enum CharKind {{
	Valid,
	Ignored,
	Mapped(MapIdx),
}}

impl CharKind {{
	/// # From Char.
	///
	/// Find the status associated with a given character. `None` implies the
	/// character is invalid.
	pub(super) fn from_char(ch: char) -> Option<Self> {{
		if let '-'..='.' | '0'..='9' | 'a'..='z' = ch {{ return Some(Self::Valid); }}

		let ch: u32 = ch as u32;
		if let Ok(idx) = MAP.binary_search_by_key(&ch, |(k, _)| *k) {{ Some(MAP[idx].1) }}
		else {{ range_search(ch) }}
	}}
}}



/// # IDNA Character Walker.
///
/// This is a very crude character traversal iterator that checks for character
/// legality and applies any mapping substitutions as needed before yielding.
///
/// This is an interator rather than a collector to take advantage of the
/// `UnicodeNormalization::nfc` trait.
///
/// The internal `error` field holds a reference to a shared error state, so
/// that afterwards it can be known whether or not the process actually
/// finished correctly.
pub(super) struct IdnaChars<'a> {{
	chars: std::str::Chars<'a>,
	remap: Option<(usize, u8)>,
	error: &'a mut bool,
}}

impl<'a> IdnaChars<'a> {{
	/// # New!
	pub(super) fn new(src: &'a str, error: &'a mut bool) -> Self {{
		Self {{
			chars: src.chars(),
			remap: None,
			error,
		}}
	}}
}}

impl<'a> Iterator for IdnaChars<'a> {{
	type Item = char;

	fn next(&mut self) -> Option<Self::Item> {{
		// Read from the mapping slice first, if present.
		if let Some((pos, len)) = &mut self.remap {{
			let ch = MAP_STR[*pos];
			if *len > 1 {{
				*pos += 1;
				*len -= 1;
			}}
			else {{ self.remap = None; }}
			return Some(ch);
		}}

		let ch = self.chars.next()?;

		// Short-circuit standard alphanumeric inputs that are totally fine.
		if let '-'..='.' | '0'..='9' | 'a'..='z' = ch {{ return Some(ch); }}

		// Otherwise determine the char/status from the terrible mapping table.
		match CharKind::from_char(ch) {{
			Some(CharKind::Valid) => Some(ch),
			Some(CharKind::Mapped(idx)) => {{
				let pos = u16::from_le_bytes([idx.a, idx.b]) as usize;
				let ch = MAP_STR[pos];
				if idx.l > 1 {{ self.remap.replace((pos + 1, idx.l - 1)); }}
				Some(ch)
			}},
			Some(CharKind::Ignored) => self.next(),
			None => {{
				*self.error = true;
				None
			}},
		}}
	}}
}}



#[allow(clippy::integer_division)]
/// # Range Search.
///
/// This is basically a binary search, but it checks to see whether the needle
/// fits a range of values, rather than looking for an exact hit.
fn range_search(ch: u32) -> Option<CharKind> {{
	let mut size = {ranges_len};
	let mut left = 0;
	let mut right = size;

	while left < right {{
		let mid = left + size / 2;
		let cmp = ch.cmp(&RANGES[mid].0);

		if cmp == std::cmp::Ordering::Less {{ right = mid; }}
		else if cmp == std::cmp::Ordering::Greater {{
			if ch <= RANGES[mid].1 {{ return Some(RANGES[mid].2); }}
			left = mid + 1;
		}}
		else {{ return Some(RANGES[mid].2); }}

		size = right - left;
	}}

	None
}}
